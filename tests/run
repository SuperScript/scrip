#!/bin/sh

home="$(pwd)"
_sort="env LC_ALL=POSIX sort"

PATH="${home}/bin:$PATH"
export PATH

scrip=scrip
basedir="${home}/tests/basedir"

####

# _silence prog
_silence() {
  "$@" >/dev/null 2>&1
}

# _sanitize < input > output
_sanitize() {
  sed \
    -e "s!${home}!...!"g
}

# _check prog
_check() {
  { "$@" 2>&1 ; echo $?; } | _sanitize
}

# _check_err prog
_check_err() {
  { "$@" 2>&1 >/dev/null ; echo $?; } | grep -E 'fatal:|(^[0-9]+)' | _sanitize
}

# _check_sort prog
_check_sort() {
  _check "$@" | ${_sort}
}

# _run headline
_run() {
  printf '\n\n#### %s\n\n' "$1"
}

####

cd tests
rm -rf "${basedir}"

_run 'bin/scrip prints usage'
_check ${scrip}

_run 'bin/scrip help offers help'
_check ${scrip} help

_run 'bin/scrip deps lists dependencies'
mkdir -p "${basedir}"
cat - > "${basedir}/scriptest" <<'EOF'
#!/bin/sh
#include "safe.sh"
safe nosuchprogram
EOF

_check env SCRIP_PATH="${home}/lib" ${scrip} deps "${basedir}/scriptest"


_run 'shout prints message to stderr'
cat - > "${basedir}/shout_test.sh" <<'EOF'
#!/bin/sh
#include "shout.sh"
shout "test message"
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/shout_test.sh" > "${basedir}/shout_test"
_check sh "${basedir}/shout_test"


_run 'shout.awk prints message to stderr'
cat - > "${basedir}/shout_awk_test.awk" <<'EOF'
#include "shout.awk"
BEGIN { shout("test message"); }
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/shout_awk_test.awk" > "${basedir}/shout_awk_test"
_check awk -f "${basedir}/shout_awk_test"


_run 'barf prints fatal message and exits with 111'
cat - > "${basedir}/barf_test.sh" <<'EOF'
#!/bin/sh
#include "barf.sh"
barf "test error"
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/barf_test.sh" > "${basedir}/barf_test"
_check sh "${basedir}/barf_test"

_run 'barf.awk prints fatal message and exits with 111'
cat - > "${basedir}/barf_awk_test.awk" <<'EOF'
#include "barf.awk"
BEGIN { barf("test error"); }
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/barf_awk_test.awk" > "${basedir}/barf_awk_test"
_check awk -f "${basedir}/barf_awk_test"

_run 'bin/scrip code resolves includes'
_check env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/scriptest"


_run 'safe succeeds with valid command'
cat - > "${basedir}/safe_success.sh" <<'EOF'
#!/bin/sh
#include "safe.sh"
safe echo "hello world"
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/safe_success.sh" > "${basedir}/safe_success"
_check sh "${basedir}/safe_success"


_run 'safe fails and shows error'
cat - > "${basedir}/safe_fail.sh" <<'EOF'
#!/bin/sh
#include "safe.sh"
safe false
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/safe_fail.sh" > "${basedir}/safe_fail"
_check sh "${basedir}/safe_fail"


_run 'atomic_to writes output atomically on success'
cat - > "${basedir}/atomic_to_test.sh" <<'EOF'
#!/bin/sh
#include "atomic_to.sh"
atomic_to "basedir/output.txt" echo "test content"
cat "basedir/output.txt"
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/atomic_to_test.sh" > "${basedir}/atomic_to_test"
_check sh "${basedir}/atomic_to_test"


_run 'atomic_to cleans up on failure'
cat - > "${basedir}/atomic_to_fail.sh" <<'EOF'
#!/bin/sh
#include "atomic_to.sh"
(atomic_to "basedir/fail_output.txt" false)
if [ -f "basedir/fail_output.txt" ]; then
  echo "ERROR: basedir/fail_output.txt should not exist"
else
  echo "OK: basedir/fail_output.txt does not exist"
fi
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/atomic_to_fail.sh" > "${basedir}/atomic_to_fail"
_check sh "${basedir}/atomic_to_fail"


_run 'atomic_to_mode writes output with correct mode'
cat - > "${basedir}/atomic_to_mode_test.sh" <<'EOF'
#!/bin/sh
#include "atomic_to_mode.sh"
atomic_to_mode "basedir/script.sh" "755" echo "#!/bin/sh"
ls -l "basedir/script.sh" | cut -d' ' -f1
cat "basedir/script.sh"
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/atomic_to_mode_test.sh" > "${basedir}/atomic_to_mode_test"
_check sh "${basedir}/atomic_to_mode_test"


_run 'atomic_to_mode cleans up on failure'
cat - > "${basedir}/atomic_to_mode_fail.sh" <<'EOF'
#!/bin/sh
#include "atomic_to_mode.sh"
(atomic_to_mode "basedir/fail_script.sh" "755" false)
if [ -f "basedir/fail_script.sh" ]; then
  echo "ERROR: basedir/fail_script.sh should not exist"
else
  echo "OK: basedir/fail_script.sh does not exist"
fi
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/atomic_to_mode_fail.sh" > "${basedir}/atomic_to_mode_fail"
_check sh "${basedir}/atomic_to_mode_fail"


_run 'pipeline pipes two commands'
cat - > "${basedir}/pipeline_simple.sh" <<'EOF'
#!/bin/sh
#include "pipeline.sh"
pipeline '' '|' echo 'hello world' '|' sed 's/^h/H/'
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/pipeline_simple.sh" > "${basedir}/pipeline_simple"
_check sh "${basedir}/pipeline_simple"


_run 'pipeline chains multiple commands'
cat - > "${basedir}/pipeline_multi.sh" <<'EOF'
#!/bin/sh
#include "pipeline.sh"
pipeline '' :: printf '%s\n' line3 line2 line1 :: sort :: head -n 1
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/pipeline_multi.sh" > "${basedir}/pipeline_multi"
_check sh "${basedir}/pipeline_multi"


_run 'pipeline with single command (no separator)'
cat - > "${basedir}/pipeline_single.sh" <<'EOF'
#!/bin/sh
#include "pipeline.sh"
pipeline '' '' echo "no pipe here"
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/pipeline_single.sh" > "${basedir}/pipeline_single"
_check sh "${basedir}/pipeline_single"


_run 'pipeline with do_ works'
cat - > "${basedir}/pipeline_do.sh" <<'EOF'
#!/bin/sh
#include "do_.sh"
do_echo() { echo "$@"; }
do_sed() { sed "$@"; }
do_ :: echo "hereur" :: sed 's/^/thereugo\n/'
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/pipeline_do.sh" > "${basedir}/pipeline_do"
_check sh "${basedir}/pipeline_do"


_run 'pipeline with do_run works'
cat - > "${basedir}/pipeline_do_run.sh" <<'EOF'
#!/bin/sh
#include "do_.sh"
#include "do_run.sh"
do_echo() { echo "$@"; }
do_tr() { tr "$@"; }
do_ :: echo "hereur" :: run sed 's/^/thereugo\n/' :: tr '[a-z]' '[A-Z]'
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/pipeline_do_run.sh" > "${basedir}/pipeline_do_run"
_check sh "${basedir}/pipeline_do_run"


_run 'pipeline with do_xrun works'
cat - > "${basedir}/pipeline_do_xrun.sh" <<'EOF'
#!/bin/sh
#include "do_.sh"
#include "do_xrun.sh"
do_echo() { printf '%s\n' "$@"; }
do_tr() { tr "$@"; }
do_ :: echo "hereur" "thereugo" :: xrun -L1 echo "X:" :: tr '[a-z]' '[A-Z]'
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/pipeline_do_xrun.sh" > "${basedir}/pipeline_do_xrun"
_check sh "${basedir}/pipeline_do_xrun"


_run 'usage prints usage message and exits with 100'
cat - > "${basedir}/usage_test.sh" <<'EOF'
#!/bin/sh
#include "usage.sh"
usage "this is output from usage to standard error"
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/usage_test.sh" > "${basedir}/usage_test"
_check sh "${basedir}/usage_test"


_run 'have_args returns 0 when enough arguments provided'
cat - > "${basedir}/have_args_success.sh" <<'EOF'
#!/bin/sh
#include "have_args.sh"
if have_args 2 arg1 arg2 arg3; then
  echo "SUCCESS: have_args returned 0"
else
  echo "FAIL: have_args returned non-zero"
fi
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/have_args_success.sh" > "${basedir}/have_args_success"
_check sh "${basedir}/have_args_success"


_run 'have_args returns 1 when not enough arguments provided'
cat - > "${basedir}/have_args_fail.sh" <<'EOF'
#!/bin/sh
#include "have_args.sh"
if have_args 3 arg1 arg2; then
  echo "FAIL: have_args returned 0"
else
  echo "SUCCESS: have_args returned 1"
fi
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/have_args_fail.sh" > "${basedir}/have_args_fail"
_check sh "${basedir}/have_args_fail"


_run 'have_args with no arguments shows usage and exits'
cat - > "${basedir}/have_args_no_args.sh" <<'EOF'
#!/bin/sh
#include "have_args.sh"
have_args
EOF

env SCRIP_PATH="${home}/lib" ${scrip} code "${basedir}/have_args_no_args.sh" > "${basedir}/have_args_no_args"
_check sh "${basedir}/have_args_no_args"


_run 'bin/pipeline prints usage and exits'
_check "${home}/bin/pipeline"

_run 'bin/pipeline requires a program'
_check "${home}/bin/pipeline" ::

_run 'bin/pipeline runs a program'
_check "${home}/bin/pipeline" :: echo hereur

_run 'bin/pipeline pipelines programs'
_check "${home}/bin/pipeline" :: echo hereur :: sh -c 'echo thereugo && cat -'


_run 'bin/scrip help takes file arguments'
_check "${home}/bin/scrip" help "${home}/bin/pipeline" "${home}/bin/scrip"


exit 0

