#!/bin/sh

home="$(pwd)"
_sort="env LC_ALL=POSIX sort"

PATH="${home}/bin:$PATH"
export PATH

scrip=scrip
basedir="${home}/tests/basedir"
bindir="bin"
libdir="lib"

####

# _silence prog
_silence() {
  "$@" >/dev/null 2>&1
}

# _sanitize < input > output
_sanitize() {
  sed \
    -e "s!${home}!...!"g
}

# _check prog
_check() {
  { "$@" 2>&1 ; echo $?; } | _sanitize
}

# _check_err prog
_check_err() {
  { "$@" 2>&1 >/dev/null ; echo $?; } | grep -E 'fatal:|(^[0-9]+)' | _sanitize
}

# _check_sort prog
_check_sort() {
  _check "$@" | ${_sort}
}

# _run headline
_run() {
  printf '\n\n==== %s ====\n\n' "$1"
}

# _check_prog progname interpreter < program
_check_prog() {
  local prog="$1"
  shift
  cat - > "${basedir}/${prog}.tmp"
  env SCRIP_PATH="${libdir}" ${scrip} code "${basedir}/${prog}.tmp" > "${basedir}/${prog}"
  rm -f "${basedir}/${prog}.tmp"
  _check "$@" "${basedir}/${prog}"
}

####

cd tests
rm -rf "${basedir}"

mkdir -p "${basedir}"
cp -r ../lib "${basedir}"
cp -r ../bin "${basedir}"
cd "${basedir}"

_run 'bin/scrip prints usage'
_check ${scrip}

_run 'bin/scrip help offers help'
_check ${scrip} help

_run 'bin/scrip deps lists dependencies'
cat - > "${basedir}/scriptest" <<'EOF'
#!/bin/sh
#include "safe.sh"
safe nosuchprogram
EOF

_check env SCRIP_PATH="${libdir}" ${scrip} deps "${basedir}/scriptest"

_run 'bin/scrip code resolves includes'
_check env SCRIP_PATH="${libdir}" ${scrip} code "${basedir}/scriptest"

_run 'bin/scrip borrow copies dependencies to current directory'
mkdir -p "${basedir}/borrow"
_check env SCRIP_PATH="${libdir}" ${scrip} borrow "${basedir}/borrow" safe.sh barf.sh shout.sh

_run 'ditto prints single argument to stdout'
_check_prog ditto_single sh <<'EOF'
#!/bin/sh
#include "ditto.sh"
ditto "test message"
EOF

_run 'ditto prints multiple arguments to stdout'
_check_prog ditto_multi sh <<'EOF'
#!/bin/sh
#include "ditto.sh"
ditto "first" "second" "third"
EOF

_run 'ditt prints single argument to stdout without newline'
_check_prog ditt_single sh <<'EOF'
#!/bin/sh
#include "ditt.sh"
ditt "test message"
EOF

_run 'ditt prints multiple arguments to stdout without newline'
_check_prog ditt_multi sh <<'EOF'
#!/bin/sh
#include "ditt.sh"
ditt "first" "second" "third"
EOF

_run 'shout prints message to stderr'
_check_prog shout_test sh <<'EOF'
#!/bin/sh
#include "shout.sh"
shout "test message"
EOF

_run 'shout.awk prints message to stderr'
_check_prog shout_awk_test.awk awk -f <<'EOF'
#include "shout.awk"
BEGIN { shout("test message"); }
EOF

_run 'barf prints fatal message and exits with 111'
_check_prog barf_test sh <<'EOF'
#!/bin/sh
#include "barf.sh"
barf "test error"
EOF

_run 'barf.awk prints fatal message and exits with 111'
_check_prog barf_awk_test.awk awk -f <<'EOF'
#include "barf.awk"
BEGIN { barf("test error"); }
EOF

_run 'safe succeeds with valid command'
_check_prog safe_success sh <<'EOF'
#!/bin/sh
#include "safe.sh"
safe echo "hello world"
EOF

_run 'safe fails and shows error'
_check_prog safe_fail sh <<'EOF'
#!/bin/sh
#include "safe.sh"
safe false
EOF

_run 'usage prints usage message and exits with 100'
_check_prog usage_test sh <<'EOF'
#!/bin/sh
#include "usage.sh"
usage "this is output from usage to standard error"
EOF

_run 'atomic_to writes output atomically on success'
_check_prog atomic_to_test sh <<'EOF'
#!/bin/sh
#include "atomic_to.sh"
atomic_to "output.txt" echo "test content"
cat "output.txt"
EOF

_run 'atomic_to cleans up on failure'
_check_prog atomic_to_fail sh <<'EOF'
#!/bin/sh
#include "atomic_to.sh"
(atomic_to "fail_output.txt" false)
if [ -f "fail_output.txt" ]; then
  echo "ERROR: fail_output.txt should not exist"
else
  echo "OK: fail_output.txt does not exist"
fi
EOF

_run 'atomic_to_mode writes output with correct mode'
_check_prog atomic_to_mode_test sh <<'EOF'
#!/bin/sh
#include "atomic_to_mode.sh"
atomic_to_mode "script.sh" "755" echo "#!/bin/sh"
ls -l "script.sh" | cut -d' ' -f1
cat "script.sh"
EOF

_run 'atomic_to_mode cleans up on failure'
_check_prog atomic_to_mode_fail sh <<'EOF'
#!/bin/sh
#include "atomic_to_mode.sh"
(atomic_to_mode "fail_script.sh" "755" false)
if [ -f "fail_script.sh" ]; then
  echo "ERROR: fail_script.sh should not exist"
else
  echo "OK: fail_script.sh does not exist"
fi
EOF

_run 'pipewith with do_ works'
_check_prog pipewith_do sh <<'EOF'
#!/bin/sh
#include "pipewith.sh"
#include "do_.sh"
do_echo() { printf '%s\n' "$*"; }
do_sed() { sed "$@"; }
pipewith do_ :: echo "hereur" :: sed 's/^/thereugo\n/'
EOF

_run 'pipewith with do_run works'
_check_prog pipewith_do_run sh <<'EOF'
#!/bin/sh
#include "pipewith.sh"
#include "do_.sh"
#include "do_run.sh"
do_echo() { printf '%s\n' "$*"; }
do_tr() { tr "$@"; }
pipewith do_ :: echo "hereur" :: run sed 's/^/thereugo\n/' :: tr '[a-z]' '[A-Z]'
EOF

_run 'pipewith with do_xrun works'
_check_prog pipewith_do_xrun sh <<'EOF'
#!/bin/sh
#include "pipewith.sh"
#include "do_.sh"
#include "do_xrun.sh"
do_echos() { printf '%s\n' "$@"; }
do_tr() { tr "$@"; }
pipewith do_ :: echos "hereur" "thereugo" :: xrun -L1 sh -c 'printf "%s\n" "$*"' xrun "X:" :: tr '[a-z]' '[A-Z]'
EOF

_run 'pipewith with single command (with separator)'
_check_prog pipewith_single sh <<'EOF'
#!/bin/sh
#include "pipewith.sh"
show() {
  printf '%s\n' "pipewith: $*" >&2
  "$@"
}
pipewith show '|' echo "no pipe here"
EOF

_run 'pipewith with single command (without separator)'
_check_prog pipewith_single sh <<'EOF'
#!/bin/sh
#include "pipewith.sh"
show() {
  printf '%s\n' "pipewith: $*" >&2
  "$@"
}
pipewith show '' echo "no pipe here"
EOF

_run 'pipewith pipes two commands'
_check_prog pipewith_simple sh <<'EOF'
#!/bin/sh
#include "pipewith.sh"
show() {
  printf '%s\n' "pipewith: $*" >&2
  "$@"
}
pipewith show '|' echo 'hello world' '|' sed 's/^h/H/'
EOF

_run 'pipewith chains multiple commands'
_check_prog pipewith_multi sh <<'EOF'
#!/bin/sh
#include "pipewith.sh"
show() {
  printf '%s ' pipewith: "$@" >&2
  printf '\n' >&2
  "$@"
}
pipewith show :: printf '%s\n' line3 line2 line1 :: sort :: head -n 1
EOF

_run 'pipeline with single command (with separator)'
_check_prog pipeline_single sh <<'EOF'
#!/bin/sh
#include "pipeline.sh"
pipeline '|' echo "no pipe here"
EOF

_run 'pipeline with single command (without separator)'
_check_prog pipeline_single sh <<'EOF'
#!/bin/sh
#include "pipeline.sh"
pipeline '' echo "no pipe here"
EOF

_run 'pipeline pipes two commands'
_check_prog pipeline_simple sh <<'EOF'
#!/bin/sh
#include "pipeline.sh"
pipeline '|' echo 'hello world' '|' sed 's/^h/H/'
EOF

_run 'pipeline chains multiple commands'
_check_prog pipeline_multi sh <<'EOF'
#!/bin/sh
#include "pipeline.sh"
pipeline :: printf '%s\n' line3 line2 line1 :: sort :: head -n 1
EOF

_run 'have_args returns 0 when enough arguments provided'
_check_prog have_args_success sh <<'EOF'
#!/bin/sh
#include "have_args.sh"
if have_args 2 arg1 arg2 arg3; then
  echo "SUCCESS: have_args returned 0"
else
  echo "FAIL: have_args returned non-zero"
fi
EOF

_run 'have_args returns 1 when not enough arguments provided'
_check_prog have_args_fail sh <<'EOF'
#!/bin/sh
#include "have_args.sh"
if have_args 3 arg1 arg2; then
  echo "FAIL: have_args returned 0"
else
  echo "SUCCESS: have_args returned 1"
fi
EOF

_run 'have_args with no arguments shows usage and exits'
_check_prog have_args_no_args sh <<'EOF'
#!/bin/sh
#include "have_args.sh"
have_args
EOF

_run 'bin/pipeline prints usage and exits'
_check "${bindir}/pipeline"

_run 'bin/pipeline requires a program'
_check "${bindir}/pipeline" ::

_run 'bin/pipeline runs a program'
_check "${bindir}/pipeline" :: echo hereur

_run 'bin/pipeline pipelines programs'
_check "${bindir}/pipeline" :: echo hereur :: sh -c 'echo thereugo && cat -'


_run 'bin/scrip docs takes file arguments'
_check "${bindir}/scrip" docs "${bindir}/pipeline" "${bindir}/scrip"

_run 'bin/scrip make emits Makefile rule'
echo _check env SCRIP_PATH="${libdir}" "${bindir}/scrip" make pipeline
_check env SCRIP_PATH="${libdir}" "${bindir}/scrip" make pipeline


exit 0

